# -*- coding: utf-8 -*-
"""numPy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kpZDrjgfFc74LyIDkJIZuw8cZx3YDKIv
"""

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]])

a

a.shape

a[0] = 10
a

a[:3]

"""NumPy is good for when making heterozygous lists and over 300 times faster than normal pythonic methods. Its purpose are for arrays which are used for structure and storing/retrieving data. ndim is a method used to find number of dimensions in an array. The size attribute helps find the fixed amount of elements in an array. dType is recorded in homogenous arrays, meaning only same type elements."""

a.ndim
len(a.shape) == a.ndim

import math

a.size == math.prod(a.shape)

a.dtype

"""There are many different types of methods used in the creation of arrays. The below are some examples."""

np.zeros(2)

np.ones(2)

np.empty(2)

np.arange(4) #same thing as shown below

"""np = []
for i in range(4):
  np.append(i)
print(f"array({np})")
"""

np.arange(2, 9, 2)

np.linspace(0, 10, num=5) #to create an array with values that are spaced linearly in specified interval

#can use dType when specifying kind of data one wants

x = np.ones(2, dtype=np.int64)
x
#it should show up as a 64 bit integer or two ones

"""np.array() - made arrays

np.sort(arr) - sorts a specific array

argsort- which is an indirect sort along a specified axis

lexsort- which is an indirect stable sort on multiple keys

searchsorted - which will find elements in a sorted array

partition - which is a partial sort

np.concatenate() - helps concatenate

"""

a = np.array([1, 2, 3, 4])
b = np.array([5, 6, 7, 8])

np.concatenate((a, b))

x = np.array([[1, 2], [3, 4]])
y = np.array([[5, 6]])

np.concatenate((x, y), axis=0)

"""arr.reshape() - reshapes the arrays into the rows and columns that you want




"""

a = np.arange(6)
b = a.reshape(3, 2)
print(b)

"""np.newaxis & np.expand_dims to increase the dimensions of your existing array

np.newaxis will increase the dimensions of your array by one dimension (1d->2d and more)
"""

a = np.array([1, 2, 3, 4, 5, 6])

a.shape

a2 = a[np.newaxis, :] #adds an extra dimension instead of (6, )
a2.shape

row_vector = a[np.newaxis, :] #same thing here
row_vector.shape

col_vector = a[:, np.newaxis]
col_vector.shapefive_up = (a > 5) | (a == 5)

a = np.array([[1 , 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
print(a[a < 5]) #adds only the list that contains values less than 5

five_up = (a >= 5)
print(a[five_up]) #uses a variable in order to print a index

"""logical operators & and | - in order to return boolean values that specify whether or not the values in an array fulfill a certain condition."""

five_up = (a > 5) | (a == 5)
print(five_up) #use | in order to combine two "and" statements

"""np.nonzero() to select elements or indices from an array & to print the indices of elements that are, for example, less than 5"""

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])

b = np.nonzero(a < 5)
print(b)

a1 = np.array([[1, 1], [2, 2]])
a2 = np.array([[3, 3], [4, 4]])
#vstack can combine together and make a stack
np.vstack((a1, a2))

#horizontally stack with hstack
np.hstack((a1, a2))

#hsplit splits a big array into multiple smaller arrays

x = np.arange(1, 25).reshape(2, 12)
np.hsplit(x, 3)
np.hsplit(x, (3, 4))

"""Can do basic operations with arrays"""

data = np.array([1, 2])
ones = np.ones(2, dtype=int)
data + ones

data - ones

data * data

data / data

a = np.array([1, 2, 3, 4])

a.sum()

#can sum over axis

b = np.array([[1, 1], [2, 2]])
b.sum(axis=0)

""" carry out an operation between an array and a single number (also called an operation between a vector and a scalar) or between arrays of two different sizes"""

data = np.array([1.0, 2.0])
data * 1.6

"""Broadcasting is a mechanism that allows NumPy to perform operations on arrays of different shapes. The dimensions of your array must be compatible, for example, when the dimensions of both arrays are equal or when one of them is 1. If the dimensions are not compatible, you will get a ValueError.

With Generator.integers, you can generate random integers from low (remember that this is inclusive with NumPy) to high (exclusive). You can set endpoint=True to make the high number inclusive.
"""

rng.integers(5, size=(2, 4))

"""use np.unique to print the unique values in your array:"""

unique_values = np.unique(a)
print(unique_values)

"""indices of unique values in a NumPy array (an array of first index positions of unique values in the array), just pass the return_index argument in np.unique()"""

unique_values, occurrence_count = np.unique(a, return_counts=True)
print(occurrence_count)

"""NumPy’s np.flip() function allows you to flip, or reverse, the contents of an array along an axis."""

arr_2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
reversed_arr = np.flip(arr_2d)
print(reversed_arr)

"""There are two popular ways to flatten an array: .flatten() and .ravel(). The primary difference between the two is that the new array created using ravel() is actually a reference to the parent array (i.e., a “view”). This means that any changes to the new array will affect the parent array as well. Since ravel does not create a copy, it’s memory efficient."""

x = np.array([[1 , 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
x.flatten()

a1 = x.flatten()
a1[0] = 99
print(x)  # Original array

print(a1)

"""ravel, the changes you make to the new array will affect the parent array.



"""

a2 = x.ravel()
a2[0] = 98
print(x)

print(a2)

"""reference to a string, which is known as the docstring. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in help() function that can help you access this information. This means that nearly any time you need more information, you can use help() to quickly find the information that you need.

generate a plot for your values, it’s very simple with Matplotlib.
"""

import matplotlib.pyplot as plt

a = np.array([2, 1, 5, 7, 4, 6, 8, 14, 10, 9, 18, 20, 22])

x = np.linspace(0, 5, 20)
y = np.linspace(0, 10, 20)
plt.plot(x, y, 'purple') # line
plt.plot(x, y, 'o')

fig = plt.figure()
ax = fig.add_subplot(projection='3d')
X = np.arange(-5, 5, 0.15)
Y = np.arange(-5, 5, 0.15)
X, Y = np.meshgrid(X, Y)
R = np.sqrt(X**2 + Y**2)
Z = np.sin(R)
ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='viridis')

"""The savetxt() and loadtxt() functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the genfromtxt function. With savetxt, you can specify headers, footers, comments, and more."""

import pandas as pd

# If all of your columns are the same type:
x = pd.read_csv('music.csv', header=0).values
print(x)

"""The ndarray objects can be saved to and loaded from the disk files with loadtxt and savetxt functions that handle normal text files, load and save functions that handle NumPy binary files with a .npy file extension, and a savez function that handles NumPy files with a .npz file extension.

The .npy and .npz files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture.

If you want to store a single ndarray object, store it as a .npy file using np.save. If you want to store more than one ndarray object in a single file, save it as a .npz file using np.savez. You can also save several arrays into a single file in compressed npz format with savez_compressed.


"""

a = np.array([1, 2, 3, 4, 5, 6])
np.save('filename', a)
b = np.load('filename.npy')
b = np.load('filename.npy')

csv_arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
np.savetxt('new_file.csv', csv_arr)
np.loadtxt('new_file.csv')