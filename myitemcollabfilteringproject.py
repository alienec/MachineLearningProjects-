# -*- coding: utf-8 -*-
"""MyItemCollabFilteringProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gdw9EDDd-3PKv9uVpPwyoel4RQ9K7n_Q
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import drive
drive.mount('/content/drive')

books_ids_titles = pd.read_csv(r"/content/books.csv", index_col=0)

books_ids_titles.head()

books_ids_ratings = pd.read_csv(r"/content/ratings.csv")
books_ids_ratings.head()

books_ids_ratings.shape

#keep book_id, title, authors, original_title

columns_to_keep = ['book_id', 'title', 'authors', 'original_title']
columns_to_drop = [col for col in books_ids_titles.columns if col not in columns_to_keep]
books_ids_titles.drop(columns=columns_to_drop, inplace=True)

books_ids_titles.head()

books_ids_ratings.head() #codedf

merged_books_df = pd.merge(books_ids_ratings, books_ids_titles, left_on = 'book_id', right_index=True)
merged_books_df.head()

merged_books_df.groupby('title').describe()

merged_books_df.groupby('title')['rating'].mean().head()

merged_books_df.groupby('title')['rating'].mean().sort_values(ascending=False).head()

merged_books_df.groupby('title')['rating'].count().sort_values(ascending=False).head()

books_rating_mean_count = pd.DataFrame(columns = ['rating_mean', 'rating_count'])
books_rating_mean_count['rating_mean'] = merged_books_df.groupby('title')['rating'].mean()
books_rating_mean_count['rating_count'] = merged_books_df.groupby('title')['rating'].count()

books_rating_mean_count.head()

plt.figure(figsize=(10, 8))
sns.set_style("darkgrid")

books_rating_mean_count['rating_mean'].hist(bins = 30, color="purple")

plt.figure(figsize=(10, 8))
sns.set_style("darkgrid")
books_rating_mean_count['rating_mean'].hist(bins=30, color ="green")

plt.figure(figsize = (10, 8))
sns.set_style("darkgrid")

sns.regplot(x="rating_mean", y="rating_count", data=books_rating_mean_count, color="brown")

books_rating_mean_count.sort_values("rating_count", ascending=False).head()

user_books_rating_matrix = merged_books_df.pivot_table(index = 'user_id', columns = 'title', values = 'rating')
user_books_rating_matrix

user_books_rating_matrix.shape

pulp_fiction_ratings = user_books_rating_matrix['To Kill a Mockingbird']

pulp_fiction_correlations = pd.DataFrame(user_books_rating_matrix.corrwith(pulp_fiction_ratings), columns = ["pd_corr"])

pulp_fiction_correlations.sort_values("pd_corr", ascending=False).head(5)

pulp_fiction_correlations = pulp_fiction_correlations.join(books_rating_mean_count["rating_count"])

pulp_fiction_correlations.head()

pulp_fiction_correlations.dropna(inplace = True)

pulp_fiction_correlations.sort_values("pd_corr", ascending = False).head(5)

pulp_fiction_correlations_50 = pulp_fiction_correlations[pulp_fiction_correlations['rating_count'] >= 50]
pulp_fiction_correlations_50.sort_values('pd_corr', ascending = False).head()

# Drop-in faster version (same Pearson corr logic, much less wasted work)

min_p = 50

# 1) Remove books that can never meet min_periods (major speedup)
cols = user_books_rating_matrix.notna().sum(axis=0).ge(min_p)

# 2) Downcast to float32 (major speed + memory win)
X = user_books_rating_matrix.loc[:, cols].astype("float32")

# 3) Correlation
all_books_correlations = X.corr(method="pearson", min_periods=min_p)
all_books_correlations.head()

books_data = [
    ['The Hunger Games (The Hunger Games, #1)', 4.0],
    ["Harry Potter and the Sorcerer's Stone (Harry Potter, #1)", 3.5],
    ['To Kill a Mockingbird', 4.5]
]
test_books = pd.DataFrame(books_data, columns = ['Books_Name', 'Books_Rating'])
test_books.head()

print(test_books['Books_Name'][0])
print(test_books['Books_Rating'][0])

all_books_correlations['To Kill a Mockingbird'].dropna()

recommended_books = pd.Series(dtype="float64")
for i in range(0, 2):
  books = all_books_correlations[test_books['Books_Name'][i]].dropna()
  books = books.map(lambda books_corr: books_corr * test_books['Books_Rating'][i])
  recommended_books = pd.concat([recommended_books, books])

recommended_books.sort_values(inplace = True, ascending = False)
recommended_books.head(10)