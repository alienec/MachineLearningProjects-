# -*- coding: utf-8 -*-
"""Attractiveness Rater.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bO5UvpcJITobzF_LtaKg5Fjt9w0-OHJo
"""

# ===============================
# üì¶ Install Mediapipe
# ===============================
!pip install mediapipe

import cv2
import numpy as np
import mediapipe as mp
from google.colab.patches import cv2_imshow
from google.colab import files

# ===============================
# üìñ Metric Descriptions & Ranges
# ===============================
metric_info = {
    "facial_symmetry_ratio": {"desc": "Measures how evenly features align on the left and right side of the face. Perfect symmetry = 1.0.",
                              "ideal": (0.95, 1.05),
                              "tips": {"low": "Slight asymmetry is common. Hairstyle adjustments or makeup contouring can help balance.",
                                       "high": "Strong symmetry. Maintain with skincare and healthy habits."}},
    "facial_thirds_ratio": {"desc": "The face is ideally divided into equal upper, middle, and lower thirds (about 33% each).",
                            "ideal": ([0.32,0.34],[0.32,0.34],[0.32,0.34]),
                            "tips": {"off": "Facial thirds differ. Hairstyles, makeup, or orthodontics can create more balance."}},
    "canthal_tilt_angle": {"desc": "The upward or downward tilt of the eyes. A slight positive tilt is often perceived as youthful.",
                           "ideal": (2,8),
                           "tips":{"low":"Eyes tilt downward. Eyeliner styles or lash emphasis can help.","high":"Youthful eye tilt present. Maintain eye health and brightness."}}
}

# ===============================
# üìä Helper Functions
# ===============================
def angle_between(p1, p2, p3):
    a = np.array(p1) - np.array(p2)
    b = np.array(p3) - np.array(p2)
    cosine_angle = np.dot(a,b) / (np.linalg.norm(a)*np.linalg.norm(b)+1e-6)
    return np.degrees(np.arccos(np.clip(cosine_angle,-1.0,1.0)))

# ===============================
# üîπ Mediapipe Setup
# ===============================
mp_face_mesh = mp.solutions.face_mesh
face_mesh = mp_face_mesh.FaceMesh(static_image_mode=True, max_num_faces=1,
                                  refine_landmarks=True, min_detection_confidence=0.5)

# ===============================
# üîπ Skin Metrics (Evenness Only)
# ===============================
def skin_metrics(img, landmarks):
    if landmarks is None or img is None:
        return None
    x_min, y_min = landmarks[:,0].min(), landmarks[:,1].min()
    x_max, y_max = landmarks[:,0].max(), landmarks[:,1].max()
    face_roi = img[y_min:y_max, x_min:x_max]

    # Evenness
    lab = cv2.cvtColor(face_roi, cv2.COLOR_BGR2LAB)
    L = lab[:,:,0]
    evenness = np.std(L)/255

    return round(evenness,3)

# ===============================
# üîπ Landmark Extraction
# ===============================
def get_landmarks(image_path):
    img = cv2.imread(image_path)
    if img is None:
        return None, None
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    results = face_mesh.process(img_rgb)
    if not results.multi_face_landmarks:
        return None, img
    face_landmarks = results.multi_face_landmarks[0]
    h, w, _ = img.shape
    landmarks = np.array([[int(p.x*w), int(p.y*h)] for p in face_landmarks.landmark])
    return landmarks, img

def draw_landmarks(img, landmarks):
    overlay = img.copy()
    if landmarks is not None:
        for (x,y) in landmarks:
            cv2.circle(overlay, (x,y), 1, (0,255,0), -1)
    return overlay

# ===============================
# üîπ Analyze Front Face
# ===============================
def analyze_front_face(image_path):
    landmarks, img = get_landmarks(image_path)
    if landmarks is None:
        print("‚ö†Ô∏è Front face landmarks not detected. Skipping analysis.")
        return None, img

    # Facial Symmetry
    left_eye = landmarks[33]
    right_eye = landmarks[263]
    nose_tip = landmarks[1]
    symmetry_ratio = abs(left_eye[0]-nose_tip[0])/(abs(right_eye[0]-nose_tip[0])+1e-6)

    # Improved Facial Thirds with Forehead Extrapolation
    forehead_points = [10, 338, 297, 332]
    top_forehead_y = int(np.mean([landmarks[i][1] for i in forehead_points]))
    eyebrow_points = [70, 107, 336, 300]
    glabella_y = int(np.mean([landmarks[i][1] for i in eyebrow_points]))
    forehead_height = glabella_y - top_forehead_y
    top_forehead_y = max(0, top_forehead_y - int(0.15 * forehead_height))
    subnasale_y = landmarks[2][1]
    chin_y = landmarks[152][1]

    third1 = glabella_y - top_forehead_y
    third2 = subnasale_y - glabella_y
    third3 = chin_y - subnasale_y
    total = third1 + third2 + third3
    thirds_ratio = [
        round(third1 / total, 2),
        round(third2 / total, 2),
        round(third3 / total, 2)
    ]

    # Eye Tilt / Canthal Tilt (slope-based)
    left_eye_outer = landmarks[33]
    right_eye_outer = landmarks[263]
    delta_y = right_eye_outer[1] - left_eye_outer[1]
    delta_x = right_eye_outer[0] - left_eye_outer[0]
    eye_tilt = np.degrees(np.arctan2(delta_y, delta_x))

    # Skin Evenness
    evenness = skin_metrics(img, landmarks)

    # Compile Stats
    stats = {
        "facial_symmetry_ratio": round(symmetry_ratio,3),
        "facial_thirds_ratio": thirds_ratio,
        "canthal_tilt_angle": round(eye_tilt,2),
        "skin_evenness": evenness
    }

    overlay = draw_landmarks(img, landmarks)
    return stats, overlay

# ===============================
# üîπ Report Printing
# ===============================
def print_report(title, stats):
    print("\n" + "="*60)
    print(f" {title}")
    print("="*60)
    for k,v in stats.items():
        label = k.replace("_"," ").title()
        info = metric_info.get(k, {})
        desc = info.get("desc", "No description available.")
        ideal = info.get("ideal", None)
        tips = info.get("tips", {})
        comparison, advice = "",""

        if ideal is not None:
            if isinstance(ideal[0], (int,float)):
                if v < ideal[0]:
                    comparison = " (below average)"
                    advice = tips.get("low","")
                elif v > ideal[1]:
                    comparison = " (above average)"
                    advice = tips.get("high","")
                else:
                    comparison = " ‚úÖ (within ideal range)"
                    advice = "Great balance here ‚Äî maintain naturally."
            elif isinstance(ideal[0], list):
                comparison = " ‚úÖ (close to ideal thirds)"
                advice = tips.get("off","")
        else:
            if k=="skin_evenness":
                comparison = " ‚úÖ (evenness metric)"
                advice = "Lower is better ‚Äî maintain skincare."

        print(f"\n{label}: {v}{comparison}")
        print(f"   ‚Üí {desc}")
        if ideal: print(f"   Ideal range: {ideal}")
        if advice: print(f"   üí° Suggestion: {advice}")

# ===============================
# üîπ Overall Score (Front Only)
# ===============================
def calculate_score(front_stats):
    weights = {
        "facial_symmetry_ratio": 0.40,
        "facial_thirds_ratio": 0.25,
        "canthal_tilt_angle": 0.15,
        "skin_evenness": 0.2
    }

    def normalize(val, ideal):
        if val==0: return 0
        if isinstance(ideal[0], list):
            diffs=[abs(val[i]-sum(r)/2) for i,r in enumerate(ideal)]
            return max(0,1-sum(diffs))
        low,high=ideal
        if val<low: return max(0,val/low)
        if val>high: return max(0,high/val)
        return 1.0

    score=0
    total_weight=0

    for k,w in weights.items():
        if k in front_stats and k in metric_info:
            norm=normalize(front_stats[k], metric_info[k]["ideal"])
            score += norm*w
            total_weight+=w
        elif k in front_stats and k=="skin_evenness":
            norm = max(0,1-front_stats[k])
            score+=norm*w
            total_weight+=w

    final_score = (score/total_weight)*10
    return round(final_score,2)

# ===============================
# üöÄ Upload Image and Run
# ===============================
print("üì§ Please upload ONE front-face image.")
uploaded = files.upload()
file_names = list(uploaded.keys())

front_img = None
for file_name in file_names:
    if file_name.lower().endswith(('.jpg','.jpeg','.png')):
        front_img = file_name
        break

if front_img is None:
    print("‚ö†Ô∏è Please upload a valid image (jpg, jpeg, or png).")
else:
    print("\nüîπ Analyzing Front Face...")
    front_stats, front_overlay = analyze_front_face(front_img)
    if front_stats:
        print_report("üìä Front Face Report", front_stats)
        cv2_imshow(front_overlay)
        print("\n‚≠ê Calculating Overall Score...")
        score = calculate_score(front_stats)
        print(f"‚≠ê Your Overall Attractiveness Score: {score} / 10")
    else:
        print("‚ö†Ô∏è Front face analysis failed.")